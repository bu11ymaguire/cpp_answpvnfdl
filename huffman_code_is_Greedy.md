-----

# 🤔 허프만 코딩(Huffman Coding): DP일까, Greedy일까?

허프만 코딩 알고리즘을 공부하다 보면 한 가지 의문이 생길 수 있습니다. "작은 문제의 최적해가 큰 문제의 최적해로 이어지는 구조라면, 이건 DP(동적 계획법) 아닌가?"하는 생각이죠.

결론부터 말하면, \*\*허프만 코딩은 전형적인 그리디 알고리즘(Greedy Algorithm)\*\*입니다. 왜 그런지 두 패러다임의 핵심적인 특징을 비교하며 알아보겠습니다.

## \#\# DP와 Greedy의 공통점과 차이점

두 알고리즘은 \*\*최적 부분 구조(Optimal Substructure)\*\*라는 속성을 공유하기 때문에 헷갈리기 쉽습니다.

> **최적 부분 구조 (Optimal Substructure)**
>
> 더 큰 문제의 최적 해(Optimal Solution)가 그 문제의 부분 문제(Subproblem)들에 대한 최적 해를 포함하고 있다는 성질.

하지만 두 패러다임을 가르는 결정적인 차이는 \*\*'각 단계에서의 선택 방식'\*\*에 있습니다.

### 📜 동적 계획법 (Dynamic Programming)

  - **모든 선택지를 고려한다:** DP는 각 단계에서 가능한 **모든 선택지**를 탐색하고, 그 결과들을 종합하여 전체 문제의 최적해를 찾아냅니다.
  - **하위 문제의 중복 해결:** 주로 \*\*겹치는 부분 문제(Overlapping Subproblems)\*\*를 해결하기 위해 메모이제이션(Memoization)이나 타뷸레이션(Tabulation)을 사용합니다.

### 🧭 그리디 알고리즘 (Greedy Algorithm)

  - **하나의 선택에 집중한다:** 그리디는 매 단계에서 **'지금 당장 최선으로 보이는 선택(Locally Optimal Choice)'** 단 하나만을 수행합니다. 그리고 그 선택이 전역적으로도 최적해로 이어진다고 가정합니다.
  - **탐욕적 선택 속성 (Greedy Choice Property):** 이 가정을 \*\*'탐욕적 선택 속성'\*\*이라고 부릅니다. 그리디 알고리즘이 성립하려면 이 가정이 참이라는 것이 반드시 증명되어야 합니다.

-----

## \#\# 왜 허프만 코딩은 Greedy인가?

허프만 코딩은 두 가지 핵심 속성을 모두 만족하는 그리디 알고리즘입니다.

1.  **최적 부분 구조 (Optimal Substructure) - DP처럼 보이는 이유**

      - `n`개 문자에 대한 최적 압축 트리는, `n-1`개 문자에 대한 최적 압축 트리로부터 만들 수 있습니다. 즉, 작은 문제의 최적해가 큰 문제의 해를 구성합니다. (`Lemma 16.3`이 이를 증명합니다.)

2.  **탐욕적 선택 속성 (Greedy Choice Property) - Greedy인 결정적 이유**

      - 허프만 알고리즘은 각 단계에서 어떤 선택을 하나요? 바로 \*\*"현재 남은 노드 중 빈도수가 가장 낮은 두 개를 선택해 합친다"\*\*는 단 하나의 탐욕적인 선택을 합니다.
      - "두 번째로 낮은 것과 세 번째로 낮은 것을 합치면 어떨까?" 와 같은 다른 선택지는 전혀 고려하지 않습니다. 오직 그 순간의 최선책만을 믿고 직진할 뿐입니다. (`Lemma 16.2`는 이 선택이 항상 최적해로 이어짐을 보장합니다.)

## \#\# 요약

| 구분 | 동적 계획법 (DP) | 그리디 알고리즘 (Greedy) |
| :--- | :--- | :--- |
| **선택 방식**| 모든 부분 문제의 해를 고려하여 최적해 도출 | 매 순간 최선의 선택을 하며, 그것이 곧 최적해라 가정 |
| **허프만 코딩**| ❌<br>(다른 노드 조합을 고려하지 않음) | ✅<br>(가장 빈도 낮은 두 노드를 무조건 선택) |

결론적으로 허프만 코딩은 \*\*"작은 문제의 최적해가 큰 문제의 최적해로 이어진다"\*\*는 `최적 부분 구조`를 가지지만, 각 단계에서 \*\*"탐욕적인 선택이 항상 옳다"\*\*는 `탐욕적 선택 속성`에 기반하여 단 하나의 경로만을 따라가므로 **그리디 알고리즘**으로 분류됩니다.
